package com.zy.spring.mildware.netty.netty10;

/**
 * 基于Netty自定义TCP协议
 * https://zhuanlan.zhihu.com/p/474772193
 * https://blog.csdn.net/lzy_zhi_yuan/article/details/117915333
 *
 * 1.如何设计自定义通信协议?
 * TCP 是一种流模式的协议，在实现自定义协议时，我们会遇到诸如以下的问题：
 * 1.应用程序如何知道业务数据是全部接收完毕的，如何解决拆包和粘包问题？
 * 2.如何实现请求/响应机制？
 * 3.如何解决超时问题和实际应用的通信需求？
 * 4.如何定义消息指令或报文类型？
 * 1.1 为了解决上述的问题，首先我们介绍一种比较通用的 TCP 通信协议，其协议结构如下：
 * +--------------+---------------+------------+---------------+-----------+-
 * | 魔数(4)| version(1)|序列化方式(1)|command(1)|SerialNo(2)|数据长度(4)|数据(n) |
 * +--------------+---------------+------------+---------------+-----------+-
 * 1.1.1 魔数：
 * 4 个字节，为了防止该 TCP 端口被意外调用。
 * 我们在收到报文后取前 4 个字节与魔数比对，如果不相同则直接拒绝并关闭连接。
 * 魔数可以随意定义，比如采用 20200803 作为魔数，它的 16 进制是 0x1343d63。
 * 1.1.2 版本号：
 * 1 个字节，仅表示协议的版本号，便于协议升级时使用。
 * 1.1.3 序列化方式：
 * 1 个字节，表示如何将 Java 对象转化为二进制数据，以及如何反序列化。
 * 1.1.4 指令：
 * 1 个字节，也可以叫报文类型，表示该消息的意图，如登录、心跳、升级，以及不同的业务指令等。
 * 最多可支持 256 种指令（-127 到 127）。
 * 1.1.5 SerialNo：
 * 2 个字节，表示整个任务的 id 或者任务的流水号，便于进行追踪。
 * 最多支持 2^16 位（-32,768 到 32,767）。
 * 1.1.6 数据长度：
 * 4 个字节，表示该字段后数据部分的长度。类似于 HTTP 协议的报文头中的 Content-Length 这个字段。
 * 最多支持 2^32 位。
 * 1.1.7 数据：
 * 具体的数据内容。
 *
 */
public class NettyServer10 {

    public static void main(String[] args) {

    }
}
